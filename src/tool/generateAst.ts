import * as fs from 'fs';

class GenerateAst {
  public static main(args: string[]) {
    if (args.length !== 1) {
      console.error('Usage: generate_ast <output directory>');
      process.exitCode = 64;
    }
    const outputDir = args[0];

    // These definitions need to match TypeScript's syntax for parameter lists
    this.defineAst(outputDir, 'Expr', [
      'Binary | left: Expr, operator: Token, right: Expr',
      'Grouping | expression: Expr',
      'Literal | value: LoxObject',
      'Unary | operator: Token, right: Expr',
    ]);
  }

  private static defineAst(
    outputDir: string,
    baseName: string,
    types: string[]
  ) {
    const path = outputDir + '/' + baseName.toLowerCase() + '.ts';
    const writeStream = fs.createWriteStream(path, {
      flags: 'w+',
    });

    writeStream.write(
      '// DO NOT EDIT: This file is generated by generateAst.ts\n'
    );
    writeStream.write(
      '// To regenerate, run `yarn ast from the root directory`\n\n'
    );
    writeStream.write("import {Token} from './token';\n");
    writeStream.write("import {LoxObject} from './types';\n\n");

    writeStream.write('export abstract class Expr {\n');

    writeStream.write('  abstract accept<R>(visitor: Visitor<R>): R;\n');

    writeStream.write('}\n\n');

    this.defineVisitor(writeStream, baseName, types);

    for (const type of types) {
      const className = type.split('|')[0].trim();
      const fields = type.split('|')[1].trim();

      this.defineType(writeStream, baseName, className, fields);
      if (types.indexOf(type) !== types.length - 1) {
        writeStream.write('\n');
      }
    }
  }

  private static defineType(
    writeStream: fs.WriteStream,
    baseName: string,
    className: string,
    fieldList: string
  ) {
    writeStream.write(`class ${className} implements ${baseName} {\n`);

    // Store parameters in fields
    const names = fieldList.split(', ').map(field => field.split(': ')[0]);
    const fields = fieldList.split(', ').map(field => field.split(': ')[1]);

    // Fields
    for (let i = 0; i < names.length; i++) {
      writeStream.write(`  ${names[i]}: ${fields[i]};\n`);
    }

    writeStream.write('\n');

    // Constructor
    writeStream.write(`  constructor(${fieldList}) {\n`);

    for (let i = 0; i < names.length; i++) {
      writeStream.write(`    this.${names[i]} = ${names[i]};\n`);
    }

    writeStream.write('  }\n\n');

    // Accept method
    writeStream.write('  public accept<R>(visitor: Visitor<R>): R {\n');
    writeStream.write(
      `    return visitor.visit${className}${baseName}(this);\n`
    );

    writeStream.write('  }\n');

    writeStream.write('}\n');
  }

  private static defineVisitor(
    writeStream: fs.WriteStream,
    baseName: string,
    types: string[]
  ) {
    writeStream.write('interface Visitor<R> {\n');
    for (const type of types) {
      const typeName = type.split('|')[0].trim();
      writeStream.write(
        `  visit${typeName}${baseName}(${baseName.toLowerCase()}: ${typeName}): R;\n`
      );
    }
    writeStream.write('}\n\n');
  }
}

GenerateAst.main(process.argv.slice(2));
